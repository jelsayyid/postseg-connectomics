"""Shared type definitions for the connectomics pipeline.

All core data structures are defined here to avoid circular imports
and provide a single source of truth for the data model.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Tuple

import numpy as np


# ---------------------------------------------------------------------------
# Enums
# ---------------------------------------------------------------------------

class ConnectionStatus(Enum):
    """Status of a candidate connection after validation."""
    PROPOSED = "proposed"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    AMBIGUOUS = "ambiguous"


# ---------------------------------------------------------------------------
# Geometry primitives
# ---------------------------------------------------------------------------

@dataclass
class BoundingBox:
    """Axis-aligned bounding box in physical coordinates (nm)."""
    min_corner: np.ndarray  # (z, y, x)
    max_corner: np.ndarray  # (z, y, x)

    @property
    def center(self) -> np.ndarray:
        return (self.min_corner + self.max_corner) / 2.0

    @property
    def size(self) -> np.ndarray:
        return self.max_corner - self.min_corner

    @property
    def volume(self) -> float:
        s = self.size
        return float(s[0] * s[1] * s[2])

    def overlaps(self, other: BoundingBox) -> bool:
        """Check if two bounding boxes overlap."""
        return bool(
            np.all(self.min_corner <= other.max_corner)
            and np.all(self.max_corner >= other.min_corner)
        )

    def expand(self, margin: float) -> BoundingBox:
        """Return a new bounding box expanded by margin on all sides."""
        return BoundingBox(
            min_corner=self.min_corner - margin,
            max_corner=self.max_corner + margin,
        )


# ---------------------------------------------------------------------------
# Fragment representations
# ---------------------------------------------------------------------------

@dataclass
class Skeleton:
    """Topological skeleton of a fragment."""
    nodes: np.ndarray       # (N, 3) node coordinates in physical units (nm)
    edges: np.ndarray       # (E, 2) index pairs into nodes
    radii: np.ndarray       # (N,) estimated radius at each node

    @property
    def num_nodes(self) -> int:
        return self.nodes.shape[0]

    @property
    def num_edges(self) -> int:
        return self.edges.shape[0]

    def path_length(self) -> float:
        """Total length of all skeleton edges."""
        if self.num_edges == 0:
            return 0.0
        diffs = self.nodes[self.edges[:, 1]] - self.nodes[self.edges[:, 0]]
        return float(np.sum(np.linalg.norm(diffs, axis=1)))


@dataclass
class Mesh:
    """Surface mesh of a fragment."""
    vertices: np.ndarray    # (V, 3) vertex coordinates in physical units (nm)
    faces: np.ndarray       # (F, 3) triangle vertex indices

    @property
    def num_vertices(self) -> int:
        return self.vertices.shape[0]

    @property
    def num_faces(self) -> int:
        return self.faces.shape[0]


@dataclass
class Fragment:
    """A single connected component extracted from the segmentation.

    This is the fundamental unit of the pipeline. Each fragment represents
    a contiguous region of voxels sharing the same segmentation label.
    """
    fragment_id: int
    label_id: int                           # Original segmentation label
    voxel_count: int
    bounding_box: BoundingBox
    centroid: np.ndarray                    # (z, y, x) in physical coordinates (nm)
    endpoints: List[np.ndarray] = field(default_factory=list)

    # Optional geometric representations
    skeleton: Optional[Skeleton] = None
    mesh: Optional[Mesh] = None

    # Chunk metadata
    is_boundary: bool = False               # Touches chunk boundary
    chunk_origin: Optional[Tuple[int, ...]] = None

    @property
    def physical_volume(self) -> float:
        """Volume of the bounding box in nm^3."""
        return self.bounding_box.volume


# ---------------------------------------------------------------------------
# Candidate connections
# ---------------------------------------------------------------------------

@dataclass
class CandidateConnection:
    """A proposed connection between two fragments.

    Generated by the candidate generator, then evaluated by the validator.
    Status starts as PROPOSED and is updated to ACCEPTED, REJECTED, or
    AMBIGUOUS after validation.
    """
    candidate_id: int
    fragment_a: int                     # Source fragment ID
    fragment_b: int                     # Target fragment ID
    endpoint_a: np.ndarray              # (z, y, x) connection point on A
    endpoint_b: np.ndarray              # (z, y, x) connection point on B

    # Individual scores (all in [0, 1], higher = more plausible)
    proximity_score: float = 0.0
    alignment_score: float = 0.0
    continuity_score: float = 0.0
    size_score: float = 0.0

    # Composite score
    composite_score: float = 0.0

    # Validation status
    status: ConnectionStatus = ConnectionStatus.PROPOSED

    @property
    def gap_distance(self) -> float:
        """Euclidean distance between the two connection points."""
        return float(np.linalg.norm(self.endpoint_b - self.endpoint_a))


# ---------------------------------------------------------------------------
# Validation results
# ---------------------------------------------------------------------------

@dataclass
class ValidationResult:
    """Result of a single validation rule applied to a candidate."""
    rule_name: str
    decision: ConnectionStatus
    confidence: float               # [0, 1]
    reason: str                     # Human-readable explanation


@dataclass
class ValidationReport:
    """Aggregate report from the validation pipeline."""
    results: dict = field(default_factory=dict)
    # Mapping: candidate_id -> List[ValidationResult]

    accepted: List[int] = field(default_factory=list)       # candidate_ids
    rejected: List[int] = field(default_factory=list)
    ambiguous: List[int] = field(default_factory=list)

    @property
    def total(self) -> int:
        return len(self.accepted) + len(self.rejected) + len(self.ambiguous)

    def summary(self) -> dict:
        return {
            "total": self.total,
            "accepted": len(self.accepted),
            "rejected": len(self.rejected),
            "ambiguous": len(self.ambiguous),
            "accept_rate": len(self.accepted) / max(self.total, 1),
        }


# ---------------------------------------------------------------------------
# Assembled structures
# ---------------------------------------------------------------------------

@dataclass
class AssembledStructure:
    """A reconstructed neuron or axon assembled from fragments.

    Represents the output of the assembly stage: a set of fragments
    connected by high-confidence validated connections.
    """
    structure_id: int
    fragment_ids: List[int] = field(default_factory=list)
    accepted_connections: List[int] = field(default_factory=list)    # candidate_ids
    ambiguous_connections: List[int] = field(default_factory=list)   # nearby unresolved

    # Quality metrics
    confidence: float = 0.0             # Min confidence across accepted connections
    total_path_length: float = 0.0      # Physical length (nm)
    num_branches: int = 0

    # Flags
    has_ambiguous_regions: bool = False
    topology_warnings: List[str] = field(default_factory=list)
